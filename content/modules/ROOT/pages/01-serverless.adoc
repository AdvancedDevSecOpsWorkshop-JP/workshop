= Application Platform としての OpenShift: 信頼性/包括的/一貫性(45 mins)

このモジュールでは、OpenShift をアプリケーション・プラットフォームとして包括的に理解します。
モダナイゼーションから、オープン・ハイブリッドクラウド上でのアプリケーションのビルド／デプロイ／管理、さらに Serverless による自動スケーリングまで、日々の作業を加速させるためのポイントを学びます。

[#introduction]
== Introduction

このモジュールでは、以下を行います。

* OpenShift のアプリケーションプラットフォームとしての機能を確認します。
* Developer Perspective を使い、Deployment と Serverless の2種類で、2つのアプリケーションを OpenShift に移行します。
* Serverless Deployments と OpenShift Pipelines について学びます。
* アプリケーションの状態、CPU 使用率、イベントを確認します。

[#openshift_as_an_application_platform_overview]
== Application Platform としての OpenShift について

*Red Hat OpenShift* は、オープンスタンダードに基づいた、 *“信頼性/包括的/一貫性”* を備えたアプリケーション・プラットフォームであり、
レガシーアプリケーションからクラウドネイティブアプリケーションまで、開発・提供・実行を成功させるための重要な機能を備えています。

image::ocp-app/devops_01_ocpapp_platform.png[width=100%]
図1. アプリケーションプラットフォームとしてのOpenShiftの概要

* *Red Hat Enterprise Linux* の *信頼性の高い基盤* の上に構築された *Red Hat OpenShift* は、オンプレミスのインフラ、パブリッククラウドのリソース、エッジデバイスを含むハイブリッドクラウド環境全体で、柔軟でスケーラブルなモダンアプリケーション開発の基盤を提供します。

* *Red Hat OpenShift* は、さまざまな環境にまたがるセキュアでスケーラブルな開発を効率化する *包括的なアプリケーションプラットフォーム* を提供します。モダナイゼーションやデプロイに伴う課題に対応し、豊富なツールとサービスにより、開発者の生産性と運用効率を高めます。

* *Red Hat OpenShift* は、開発者・運用担当者・プラットフォームエンジニアに対して、*一貫性のあるユーザー体験* を提供します。オンプレミス、パブリッククラウド、エッジ、ハイブリッドインフラのいずれであっても、好きなツールを使って、どこにでも迅速にアプリをビルド／デプロイできる自由を提供します。


== OpenShift console から Application Platform としての OpenShift を確認する

このセクションでは、*Image Build*、*Runtimes*、*Serverless*、*CI/CD* など、これまでに触れた機能の一部を実際に確認していきます。

*Red Hat OpenShift* では、*Developer perspective* を使ってアプリケーションおよび関連するコンポーネント／サービスを作成し、それらがどのように連携して動くかを定義し、時間の経過とともに健全性を監視できます。


=== UBI Images を利用する

Red Hat Universal Base Images（UBI）は、OCI 準拠のコンテナ用ベース OS イメージであり、補完的なランタイム言語やパッケージを含み、自由に再配布できます。
https://www.redhat.com/ja/blog/introducing-red-hat-universal-base-image[Red Hat Universal Base Image の (再) 紹介^]

Developer perspective では、OpenShift 上でビルドおよびデプロイする新規アプリケーションのベースイメージとして、UBI イメージを選択できます。


=== *Serverless を利用する*
Serverless のクラウドコンピューティングモデルは、ハイブリッドクラウド向けに、モダンでクラウドネイティブなアプリ開発スタックを開発者に提供します。
Serverless により、開発者はインフラを気にすることなくコードに集中できます。
Red Hat® OpenShift® Serverless は、単一ベンダーへのロックインを避け、マルチクラウドのアプローチを可能にします。
オープンソースの *Knative project* をベースとする *Red Hat OpenShift Serverless* は、イベント駆動のクラウドネイティブアプリを、シンプルかつ効率的にスケール可能な形で開発するための “橋渡し” となります。
*Knative* には主に *Knative Serving* と *Knative Eventing* の2つのコンポーネントがあります。

=== *Serverless のメリット*

- クラウドネイティブ開発の簡素化
- 自動スケーリング
- マルチクラウドでの可搬性
- 幅広い統合性
- 組み込みのセキュリティ
- エンタープライズグレードのアプリケーション・プラットフォーム

=== *Knative Eventing*

image::ocp-app/serverless_types.png[width=100%]


* https://docs.openshift.com/serverless/latest/about/about-knative-serving.html[Knative Serving^] を使うと、クラスター上に Knative service や function を作成できます。また、アプリケーション向けの自動スケーリングやネットワーク設定など、追加の機能も利用できます。

* https://docs.openshift.com/serverless/latest/about/about-knative-eventing.html[Knative Eventing^] を使うと、event source、broker、channel などの Knative コンポーネントを作成し、それらを用いてアプリケーションや外部システムにイベントを送信できます。

=== *Knative Serving*

image::ocp-app/serverless_serving.png[width=100%]

== OpenShift Web Console を使ってアプリケーションをモダナイズする

=== アプリケーションの概要

- *Web NodeJS*: 最近作成したアプリケーションで、ユーザーが coolstore と対話するための UI を提供します。
- *Gateway-vertx*: UI と、その他のアプリケーションサービス群の間を中継するゲートウェイとして動作する Java アプリケーションです。
- *Inventory*: Quarkus で構築された Java ベースのアプリケーションで、各商品の在庫情報を提供します。UI では、商品ごとの利用可能数量として表示されます。
- *Catalog*: Spring Boot で構築された Java ベースのアプリケーションで、カタログ情報全体を提供します。このサービスがないと、UI 上にカタログデータは表示されません。

image::ocp-app/coolstore_diagram.png[width=80%]
coolstore のマイクロサービス群を構成する最終的なトポロジー（Topology）表示のイメージ

[#building_a_serverless_application_with_the_openshift_application_platform]
== OpenShift Application Platform で Serverless アプリケーションを構築する

=== OpenShift Web Console にアクセスする

以下の URL から OpenShift Console にアクセスできます。

link:{openshift_console_url}[{openshift_console_url},window='_blank']

ログイン画面が表示され、2つの選択肢があるので、*Keycloak* を選んでください。

image::ocp-app/openshift_login.png[width=80%]

[IMPORTANT]
誤って `htpasswd_provider` でログインしてしまうと、Keycloak では OpenShift にログインできなくなります。
Keycloak で再度ログインする前に、OpenShift の user と identity を削除して修正する必要がありますので、講師に依頼してください。

Keycloak にリダイレクトされるので、認証情報を使ってログインします:

* *User*:
+
[.console-input]
[source,subs="attributes"]
----
{user}
----

* *Password*:
+
[.console-input]
[source,subs="attributes"]
----
{password}
----

ログイン後、OpenShift Console に戻ります。

=== ターミナルから OpenShift にログインする

Keycloak SSO を利用しているため、コンソールから CLI ログインコマンドをコピーする必要があります。
画面右上のユーザー名をクリックし、`Copy login command` を選択してください。

image::ocp-app/copy_login_command.png[width=80%]

Keycloak にリダイレクトされるので、認証情報でログインします:

* *User*:
+
[.console-input]
[source,subs="attributes"]
----
{user}
----

* *Password*:
+
[.console-input]
[source,subs="attributes"]
----
{password}
----

ログイン後、`Display Token` というリンクがあるページが表示されるので、そのリンクをクリックしてトークンを表示します。以下のように `oc login` コマンドをコピーし、ターミナルに貼り付けてください。

image::ocp-app/oc_login_command.png[width=80%]

コマンドを貼り付けると、証明書の受け入れ確認が表示されるので、以下のように 'y' を入力します。

[.console-output]
[source,subs="+attributes,macros+"]
----
[lab-user: ~]$ oc login --token=sha256~F2yqBi9f01H0AJHxwozAERhGbKvX4RMFBba-ijY27t0 --server=https://api.cluster-jpq8b.jpq8b.sandbox406.opentlc.com:6443
The server uses a certificate signed by an unknown authority.
You can bypass the certificate check, but any data you send to the server could be intercepted by others.
Use insecure connections? (y/n): y

WARNING: Using insecure TLS client config. Setting this option is not supported!

Logged into "https://api.cluster-jpq8b.jpq8b.sandbox406.opentlc.com:6443" as "{user}" using the token provided.

You have access to the following projects and can switch between them with 'oc project <projectname>':

  * {user}-argocd
    {user}-cicd
    {user}-dev
    {user}-prod

Using project "{user}-argocd".
Welcome! See 'oc help' to get started.
----

[NOTE]
OpenShift の新しいバージョンでは `oc login --web <openshift-api-url>` を使うことで、この手順を避けられます。
これは localhost 上で Web サーバーを起動し、OIDC のリダイレクト処理を行う方式です。
ただし本ワークショップでは、ターミナルを pod 内で実行しているため、Keycloak が pod 内のターミナルへリダイレクトして戻すことができません。
そのため、このワークショップでは `Copy login command` の手順を使用します。

=== プロジェクトを作成する

* {app_name} をデプロイするための新しいプロジェクトを作成します。ターミナルで以下のコマンドを実行してください。

[.console-input]
[source,sh,subs="attributes",role=execute]
----
oc new-project coolstore-dev-{user}
----

* Githubのリポジトリからクローンしてファイルにアクセスします。

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
git clone -b main --single-branch https://gitea-gitea.{subdomain}/user1/workshop ~/workshop
----

* catalog をデプロイする yaml ファイルを確認します。

[.console-input]
[source,bash,subs="+attributes,macros+"]
----
cd ~/workshop/content/modules/ROOT/files/module-01
----

* Coolstore のコンポーネントをインストールします。

[.console-input]
[source,bash,subs="+attributes,macros+"]
----
oc apply -f coolstore.yaml
----
[.console-output]
[source,subs="+attributes,macros+"]
----
output:
    deployment.apps/gateway-vertx created
    service/gateway-vertx created
    route.route.openshift.io/gateway-vertx created
    deployment.apps/inventory-quarkus created
    service/inventory-quarkus created
----

=== Topology view を確認する
Web コンソールの Developer perspective にある Topology view は、プロジェクト内のすべてのアプリケーション、ビルド状況、関連コンポーネント／サービスを可視化して表示します。

==== Coolstore アプリケーションを構成するマイクロサービス群を確認する

** *Topology* をクリックして Developer Perspective にアクセスします。

image::ocp-app/coolstore_topology.png[width=80%]

表示されているコンポーネントはすべて deployment で、アプリケーションの管理を担います。
すべて青色になっているのは、アプリケーションが稼働中であることを示します。
矢印は、どのコンポーネント同士が接続されているかを示します。

https://docs.openshift.com/container-platform/latest/applications/odc-viewing-application-composition-using-topology-view.html[Topology view の詳細はこちら^]

ご覧のとおり、UI と catalog 以外はそろっています。次のセクションでは、この UI を OpenShift に移行します。

=== アプリケーションをインポートする

このセクションでは、Developer Perspective を使って UI のソースコードを OpenShift に取り込みます。

1. 左メニューの *Developer* をクリックして Developer Perspective に切り替えます。
2. *+Add* をクリックします。
3. Git Repository の下にある、*Import from Git* を選択します。
4. Git Repo URL を入力します。
+
[.console-input]
[source,bash,subs="+attributes",role=execute]
----
https://github.com/rhpds/web-nodejs.git
----
+

*Note*: "Danger alert: Import is not possible." というエラーは無視してください。後で Builder Option を更新します。

5. *Import Strategy* を編集し、*Builder Image* を選択します（Node.js のまま、Builder Image のバージョンを 18-ubi8 に変更）。
+
image::ocp-app/use-builder-image-ubi-18.png[width=80%]
+
6. Deploy -> Resource Type で、*Serverless Deployment* を選択します。
7. *Show advanced Deployment option* をクリックし、Gateway URL に接続するための *環境変数* を追加します。

*Note*: 貼り付ける前に、Gateway URL 全体をコピーしていることを確認してください。

    - *name*:
+
[.console-input]
[source,subs="+attributes",role=execute]
----
SECURE_COOLSTORE_GW_ENDPOINT
----

    - *value*:
+
[.console-input]
[source,subs="+attributes",role=execute]
----
https://gateway-vertx-coolstore-dev-{user}.{openshift_cluster_ingress_domain}/
----

以下のように入力内容が一致していることを確認します。

image::ocp-app/serverless.png[width=80%]

* *Create* をクリックします。

https://docs.openshift.com/container-platform/latest/applications/creating_applications/odc-creating-applications-using-developer-perspective.html[参考情報^]

==== ビルドとデプロイを確認する

1. *No Revisions* をクリックして新しい Service を選択します。
2. 右側メニューの *Resources* タブをクリックします。

image::ocp-app/serverless_resources.png[width=80%]

*Note*: build が完了すると Revision が Ready になります。

* ビルド処理を確認します:

1. *Builds* セクションの *View Logs* をクリックします。
2. ビルドが実行中で、ログに問題がないことを確認します。完了すると、ログの最終行に *Push successful* と表示されます。

**Notes**: ビルドが完了するまで数分かかる場合があります。

image::ocp-app/build_ok.png[width=80%]

ビルド完了後、アプリケーションは正常に起動します。

* 左メニューの *Topology* をクリックして *Topology view* に戻ります。

image::ocp-app/coolstore_topology_web.png[width=80%]

ビルド完了後にアプリケーションが起動します。
また、Web ブラウザからアプリケーションにアクセスし HTTP リクエストを受けると、アプリケーションが再起動（起動）します。

==== アプリケーションが稼働していることを確認する

* Resources タブの *Routes* をクリックし、アプリケーションが稼働していることを確認します。


image::ocp-app/coolstore_website_black.png[width=80%]

**Notes**: ご覧のとおり、現時点では catalog が表示されません。catalog データにアクセスするには catalog アプリケーションをインストールする必要があります。

* Web Console の *Topology view* に戻り、Web アプリケーションを選択します。

* *Resources Tab* -> *Pods* セクションの *View logs* をクリックして、アプリケーションログを確認します。

image::ocp-app/logs_webui.png[width=60%]

* トラフィックがなくなると pod が *zero* までスケールダウンすることを確認します。Serverless アプリケーションはトラフィックを受けて初めて稼働し、受信するトラフィック量に応じて pod が作成されます。

https://docs.openshift.com/serverless/latest/knative-serving/autoscaling/serverless-autoscaling-developer.html[Serving Autoscaling の詳細情報^]

*おめでとうございます!*
ほんの数クリックで OpenShift に新しいアプリケーションをビルドしてデプロイできました！

[#building_a_backend_application_using_the_openshift_application_platform_with_openshift_pipelines]
== OpenShift Pipelines を使って OpenShift Application Platform 上でバックエンドアプリケーションを構築する

このセクションでは、Developer Perspective を使って catalog（Java Spring Boot）アプリケーションを OpenShift に移行します。OpenShift は、自動化された CI/CD パイプラインと、アプリケーションに必要な マニフェスト 一式を作成します。


=== *OpenShift Pipelines による CI/CD*

Red Hat OpenShift Pipelines は、Kubernetes リソースをベースにしたクラウドネイティブな継続的インテグレーション／継続的デリバリー（CI/CD）ソリューションです。
Tekton のビルディングブロックを利用し、基盤となる実装の詳細を抽象化することで、複数プラットフォームにまたがるデプロイを自動化します。
Tekton は、Kubernetes ディストリビューションをまたいで移植可能な CI/CD パイプラインを定義するために、標準的な Custom Resource Definitions（CRDs）を複数導入しています。


https://docs.openshift.com/pipelines/latest/about/understanding-openshift-pipelines.html[OpenShift Pipelines^] は、CI/CD パイプラインの各ステップをそれぞれ独立したコンテナで設計・実行できる、Kubernetes ネイティブな CI/CD フレームワークを提供します。オンデマンドのパイプラインに合わせて独立してスケールでき、予測可能な結果を得られます。

=== OpenShift Pipeline の概念

* *Task* リソースはパイプラインの構成要素であり、順次実行されるステップで構成されます。基本的には、入力と出力を持つ “関数” のようなものです。

* *Steps* は、Task によって順次実行される一連のコマンドで、イメージのビルドなど、特定の目的を達成します。

* *Task Run* は、入力と出力を指定して Task を実行する（呼び出す）ことです。

image::ocp-app/task_run.png[width=80%]

* *Pipeline Resource* は、Task や Pipeline の入力／出力（git、image など）です。
* *Pipeline* は、一定の順序で実行される Task のグラフです。
* *Pipeline Run* は、入力と出力を指定して Pipeline を実行する（呼び出す）ことです。

image::ocp-app/pipeline_run.png[width=80%]

=== バックエンドアプリケーションを作成する


1. Developer Perspective にアクセスします。
2. *+Add* をクリックします。
3. Git Repository の下にある、*Import from Git* を選択します。
4. Git Repo URL を入力します。
+
[.console-input]
[source,bash,subs="+attributes",role=execute]
----
https://github.com/rhpds/catalog-spring-boot.git
----
+

*Note*: "Danger alert: Import is not possible." というエラーは無視してください。後で Builder Option を更新します。

5. *Import Strategy* を編集し、*Builder Image* を選択します（Java のまま、Builder Image のバージョンは *openjdk-17-ubi8*）。
6. Build -> Build Option で *Pipelines* を選択します。
7. Resource Type で *Deployment* を選択します。

以下のように入力内容が一致していることを確認します。

image::ocp-app/deployment.png[width=80%]

* *Create* をクリックします。

==== ビルドとデプロイを確認する

* Topology view で新しい Deployment *catalog-spring-boot* をクリックします。
* *Pipeline Runs* をクリックします。

image::ocp-app/pipelines_detail.png[width=80%]

* Pipeline が実行中で、すべてが緑（成功）になっていることを確認します。

**Notes**: Pipeline が完了するまで数分かかる場合があります。Pipeline Run のログも確認してみてください。

image::ocp-app/pipelines_deployment.png[width=80%]

Pipeline が完了すると、Pipeline Succeeded と表示され、Pod が正常に稼働します。

* Pipeline のログを確認します。

** Logs タブをクリックし、各 Task が出力するログを確認します。

image::ocp-app/pipeline_logs.png[width=60%]

* アプリケーションが期待どおり稼働していることを確認します。
** 左メニューの *Topology* をクリックして topology view に戻ります。
** UI の Serverless deployment（*web-nodejs-git...*）をクリックします。
** Resources タブの *Routes* をクリックし、アプリケーションが稼働していることを確認します。

これで catalog 情報が表示されるようになります。

image::ocp-app/coolstore_website.png[width=80%]


* アプリケーションの CPU 使用率を確認する

OpenShift Container Platform の Web Console の Observe セクションでは、メトリクス、アラート、監視ダッシュボード、メトリクスのターゲットなど、監視機能にアクセスして管理できます。
https://docs.openshift.com/container-platform/4.14/monitoring/monitoring-overview.html[監視機能の詳細はこちら^]

* Topology View に戻り、左メニューの *Topology* をクリックします。

* *Observe* タブを開きます。

image::ocp-app/coolstore_topology_observe.png[width=60%]

* *View Dashboard* をクリックして、アプリケーションのメトリクスを確認します。

image::ocp-app/view_dashboard.png[width=0%]

* *CPU Usage* を確認します。

image::ocp-app/dashboard_metrics.png[width=80%]

* 用可能なメトリクスをすべて確認します。

** Dashboard のドロップダウンから、さまざまなメトリクスを選択します。

image::ocp-app/available_metrics.png[width=80%]

* *events* を確認します。

image::ocp-app/events.png[width=80%]

https://docs.openshift.com/container-platform/latest/observability/monitoring/about-ocp-monitoring/about-ocp-monitoring.html[Reviewing monitoring dashboards^]

[#conclusion]
== セクションの振り返り

Developer Perspective を使うと、アプリケーションを作成・ビルド・管理できます（コマンドラインでも同様に実施可能です）。
Developer perspective は強力なツールであり、Git リポジトリ、helm chart、jar file など、さまざまなソースからアプリケーションを取り込めます。

*Serverless* を使うことで、運用の負担を抱えることなくアプリケーションをデプロイできます。
プリケーションの pod は受信トラフィック量に応じて作成されます。
Serverless は、トラフィックを受けている間だけアプリケーションが稼働するため、コスト削減にもつながります。

*OpenShift Pipelines* は、CI/CD によるアプリケーションのビルドとデプロイを可能にします。
Pipelines は選択時に自動生成できます。また、組織の要件やガイドラインを踏まえて、生成されたパイプラインを強化・拡張できます。

[#more_information]
== 参考情報

* https://docs.openshift.com/container-platform/latest/applications/creating_applications/odc-creating-applications-using-developer-perspective.html[Creating applications using the Developer perspective^]
* https://docs.openshift.com/container-platform/latest/applications/odc-viewing-application-composition-using-topology-view.html[Viewing application composition using the Topology view^]

* https://docs.openshift.com/pipelines/latest/create/working-with-pipelines-web-console.html[Working with Red Hat OpenShift Pipelines in the web console^]

* https://docs.openshift.com/pipelines/latest/about/about-pipelines.html[Pipelines^]

* https://docs.openshift.com/container-platform/latest/applications/index.html[Builds^]
